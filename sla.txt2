
Vou enviar para voc√™, dois projetos que tenho implementado de uma disciplina de Sistemas Distribuidos, guarde no historico esses dois projetos, pois irei pedir para voce construir o projeto final tomando base esses projetos previamente informados. 

Projeto 1
import { Request, Response } from "express";
import { LamportClockService } from "../services/LamportClockService";

export class LamportController {
  private lamporClockService: LamportClockService;

  constructor(nodePort: number) {
    this.lamporClockService = new LamportClockService(nodePort);
  }

  async sendEvent(req: Request, res: Response): Promise<Response> {
    const { targetPort } = req.params;
    await this.lamporClockService.sendEvent(Number(targetPort));
    return res.status(200).send();
  }

  receiveEvent(req: Request, res: Response): Response {
    const { timestamp } = req.body;
    this.lamporClockService.receiveEvent(timestamp);
    return res.status(200).send();
  }
}

export interface ILamportClock {
  sendEvent(targertPort: number ): Promise<void>;
  receiveEvent(receivedClock: number): void;
}

import { Router, Request, Response } from "express";
import { LamportController } from "../controllers/LamportController";

export const createRouter = (nodePort: number) : Router => {
  const router = Router();
  const lamportController = new LamportController(nodePort);

  router.post("/message/:targetPort", (req: Request, res: Response) => {lamportController.sendEvent(req, res)});
  router.post("/message", (req: Request, res: Response) => {lamportController.receiveEvent(req, res)});

  return router;
}

import axios from "axios";
import { ILamportClock } from "../interfaces/ILamportClock";
import { LamportClock } from "../LamportClock";

export class LamportClockService implements ILamportClock{
  private lamportClock: LamportClock
  private nodePort: number;

  constructor(nodePort: number) {
    this.lamportClock = LamportClock.getInstance();
    this.nodePort = nodePort;
  }

  private increment(): void {
    this.lamportClock.setTime(this.lamportClock.getTime() + 1);
  }

  async sendEvent(targetPort: number): Promise<void> {
    this.increment();
    try{
      await axios.post(`http://localhost:${targetPort}/message`, { timestamp: this.lamportClock.getTime() });
      console.log(`üì® [N√≥ ${this.nodePort}] Mensagem enviada para ${targetPort} | Clock: ${this.lamportClock.getTime()}`);
    } catch (error: any)  {
      console.error(`‚ùå Erro ao enviar mensagem para ${targetPort}`, error.message);
    }
  }

  receiveEvent(receivedClock: number): void {
    this.lamportClock.setTime(Math.max(this.lamportClock.getTime(), receivedClock) + 1);
    console.log(`üì• [N√≥ ${this.nodePort}] Evento recebido | Clock atualizado: ${this.lamportClock.getTime()}`);
  }
}

export class LamportClock {
  private clock: number;
  private static instance: LamportClock;

  constructor() {
    this.clock = 0;
  }

  getTime(): number {
    return this.clock;
  }

  setTime(time: number): void {
    this.clock = time;
  }

  static getInstance(): LamportClock {
    if (!LamportClock.instance) {
      LamportClock.instance = new LamportClock();
    }
    return LamportClock.instance;
  }
}

import { Express } from "express"
import express = require("express");
import { createRouter } from "./routers/routes";

const app: Express = express();

app.use(express.json());

const args = process.argv.slice(2);
const port = parseInt(args[0]);

app.use("/", createRouter(port));

app.listen(port, () => {
  console.log(`Server running on port ${port}`);
});

import { Request, Response } from 'express';
import { ProcessService } from '../services/ProcessService';

export class ProcessController {
  constructor(private processService: ProcessService) {}

  connect = (req: Request, res: Response) => {
    const { neighbor } = req.body;
    this.processService.connect(neighbor);
    res.send({ message: `Connected to ${neighbor}` });
  };

  sendMessage = (req: Request, res: Response) => {
    const { to, message } = req.body;
    this.processService.sendMessage(to, message);
    res.send({ message: `Message sent to ${to}` });
  };

  receiveMessage = (req: Request, res: Response) => {
    const { from, message } = req.body;
    this.processService.receiveMessage(from, message);
    res.send({ message: 'Message received' });
  };

  initiateSnapshot = (req: Request, res: Response) => {
    const neighbors = this.processService.initiateSnapshot();
    res.send({ message: 'Snapshot initiated', neighbors });
  };

  receiveMarker = (req: Request, res: Response) => {
    const { from } = req.body;
    this.processService.receiveMarker(from);
    res.send({ message: 'Marker received' });
  };

  getState = (req: Request, res: Response) => {
    res.json(this.processService.getState());
  };

  checkSnapshotCompletion = (req: Request, res: Response) => {
    this.processService.checkSnapshotCompletion();
    res.send({ message: 'Snapshot completion checked' });
  };
}

import express from 'express';
import { ProcessService } from '../services/ProcessService';
import { ProcessController } from '../controllers/ProcessController';

const router = express.Router();
const processService = new ProcessService(Number(process.argv[2] || 3000));
const processController = new ProcessController(processService);

router.post('/connect', processController.connect);
router.post('/send', processController.sendMessage);
router.post('/receive', processController.receiveMessage);
router.post('/snapshot', processController.initiateSnapshot);
router.post('/marker', processController.receiveMarker);
router.get('/state', processController.getState);
router.post('/snapshot/complete', processController.checkSnapshotCompletion);

export { router as processRouter };

import axios from 'axios';

export class ProcessService {
  private port: number;
  private neighbors: string[] = [];
  private state: { processId: number; localState: string; receivedMessages: string[] };
  private recording: boolean = false;
  private channelBuffer: Record<string, string[]> = {};
  private markersReceived: Set<string> = new Set();

  constructor(port: number) {
    this.port = port;
    this.state = { processId: port, localState: `State of ${port}`, receivedMessages: [] };
  }

  connect(neighbor: string) {
    if (!this.neighbors.includes(neighbor)) {
      this.neighbors.push(neighbor);
      this.channelBuffer[neighbor] = [];
    }
  }

  async sendMessage(to: string, message: string) {
    if (!this.neighbors.includes(to)) return;

    console.log(`Process ${this.port} sends message to ${to}: ${message}`);
    try {
      await axios.post(`http://localhost:${to}/process/receive`, { from: this.port, message });
      if (this.recording) {
        this.channelBuffer[to]?.push(message);
      }
    } catch (error: any) {
      console.error(`Error sending message to ${to}:`, error.message);
    }
  }

  receiveMessage(from: string, message: string) {
    console.log(`Process ${this.port} received message from ${from}: ${message}`);

    if (this.recording) {
      this.channelBuffer[from] = this.channelBuffer[from] || [];
      this.channelBuffer[from].push(message);
    } else {
      this.state.receivedMessages.push(message);
    }
  }

  initiateSnapshot() {
    console.log(`Process ${this.port} initiates snapshot.`);
    
    this.recordState();
    this.sendMarkerToNeighbors();
  }

  async receiveMarker(from: string) {
    if (!this.recording) {
      console.log(`Process ${this.port} starts recording state.`);
      this.recordState();
      await this.sendMarkerToNeighbors();
    } else {
      console.log(`Process ${this.port} received late MARKER from ${from}.`);
    }
    
    this.markersReceived.add(from);
    this.checkSnapshotCompletion();
  }

  async sendMarkerToNeighbors() {
    await Promise.all(this.neighbors.map(async neighbor => {
      console.log(`Process ${this.port} sends MARKER to ${neighbor}`);
      try {
        await axios.post(`http://localhost:${neighbor}/process/marker`, { from: this.port });
      } catch (error: any) {
        console.error(`Error sending marker to ${neighbor}:`, error.message);
      }
    }));
  }

  checkSnapshotCompletion() {
    if (this.markersReceived.size === this.neighbors.length) {
      console.log(`Process ${this.port} completed its snapshot.`);
      this.recording = false;
    }
  }

  getState() {
    return { ...this.state, channelBuffer: this.channelBuffer };
  }

  private recordState() {
    this.recording = true;
    this.state.localState = `Recorded state of ${this.port}`;
    this.markersReceived.clear();
    Object.keys(this.channelBuffer).forEach(key => this.channelBuffer[key] = []);
  }
}

import express from 'express';
import { processRouter } from './routes/ProcessRoutes';

const app = express();
app.use(express.json());

const port = process.argv[2] || 3000;
app.use('/process', processRouter);

app.listen(port, () => {
  console.log(`Process running on port ${port}`);
});

import express from 'express';
import { ElectionService } from '../services/ElectionService';

export class ElectionController {
  private electionService: ElectionService;

  constructor(electionService: ElectionService) {
      this.electionService = electionService;
  }

  async handleElection(req: express.Request, res: express.Response) {
    if (!this.electionService.getNode().isAlive) {
      return res.sendStatus(410);
    }

    await this.electionService.startElection();
    res.sendStatus(200);
  }

  handleCoordinator(req: express.Request, res: express.Response): void {
    const newLeaderId = req.body.coordinator;
    this.electionService.getNode().leaderId = newLeaderId;
    console.log(`üëë [N√≥ ${this.electionService.getNode().id}] Novo coordenador: N√≥ ${newLeaderId}`);
    res.sendStatus(200);
  }

  handleHeartbeat(req: express.Request, res: express.Response) {
    if(!this.electionService.getNode().isAlive) {
      return res.sendStatus(410); 
    }
    res.sendStatus(200);
  }
}

import express from "express";
import { Node } from "../Node";
import { ElectionService } from "../services/ElectionService";
import { ElectionController } from "../controllers/ElectionController";

export const createRouter = (nodeId: number, ports: number[]): express.Router => {
  const router = express.Router();
  const node = new Node(nodeId);
  const electionService = new ElectionService(node, ports);
  const electionController = new ElectionController(electionService);

  router.post("/election", (req, res) => {electionController.handleElection(req, res)});
  router.post("/coordinator", (req, res) => electionController.handleCoordinator(req, res));
  router.get("/heartbeat", (req, res) => {electionController.handleHeartbeat(req, res)});

  return router;
};

import axios from 'axios';
import { Node } from '../Node';

export class ElectionService {
  private node: Node;
  private ports: number[];
  private readonly HEARTBEAT_INTERVAL = 5000;

  constructor(node: Node, ports: number[]) {
      this.node = node;
      this.ports = ports;
      this.initializeLeader(); // Defini√ß√£o do l√≠der inicial (elei√ß√£o)
      this.startSimulation();  // Simula√ß√£o de falhas (elei√ß√£o)
      this.startHeartbeat();   // In√≠cio do monitoramento por heartbeat
  }

  // === Algoritmo de Elei√ß√£o ===
  async initializeLeader(): Promise<void> {
      const allNodes = [...this.ports, this.node.id];
      const highestId = Math.max(...allNodes);
      
      this.node.leaderId = highestId;
      
      if (this.node.id === highestId) {
          console.log(`üèÜ [N√≥ ${this.node.id}] Iniciando como COORDENADOR inicial!`);
          await this.declareLeadership();
      } else {
          console.log(`üîé [N√≥ ${this.node.id}] Coordenador inicial detectado: N√≥ ${highestId}`);
      }
  }

  async declareLeadership(): Promise<void> {
      for (const port of this.ports) {
          try {
              await axios.post(`http://localhost:${port}/coordinator`, { coordinator: this.node.id });
          } catch (error:any) {
              console.error(`Erro ao notificar n√≥ ${port}:`, error.message);
          }
      }
  }

  async startElection(): Promise<void> {
      if (!this.node.isAlive) return;
      console.log(`\nüîÑ [N√≥ ${this.node.id}] Iniciando elei√ß√£o...`);
      
      const higherNodes = this.ports.filter(port => port > this.node.id);
      let responses = 0;

      for (const port of higherNodes) {
          try {
              await axios.post(`http://localhost:${port}/election`, {}, { timeout: 3000 });
              responses++;
          } catch (error) {
              console.error(`üö® [N√≥ ${this.node.id}] N√≥ ${port} n√£o respondeu`);
          }
      }

      if (responses === 0) {
          await this.becomeLeader();
      }
  }

  async becomeLeader(): Promise<void> {
      this.node.leaderId = this.node.id;
      console.log(`üèÜ [N√≥ ${this.node.id}] Agora sou o COORDENADOR!`);
      await this.declareLeadership();
  }

  // === Simula√ß√£o de falhas e recupera√ß√£o (Relacionado √† Elei√ß√£o) ===
  async failNode(): Promise<void> {
      this.node.isAlive = false;
      console.log(`‚ùå [N√≥ ${this.node.id}] Falhou!`);
      
      // Recupera√ß√£o autom√°tica ap√≥s tempo aleat√≥rio
      setTimeout(() => this.recoverNode(), Math.random() * 10000 + 5000);
  }

  async recoverNode(): Promise<void> {
      this.node.isAlive = true;
      console.log(`‚úÖ [N√≥ ${this.node.id}] Recuperado! Verificando lideran√ßa...`);
      await this.startElection();
  }

  startSimulation(): void {
      // Simula√ß√£o de falha aleat√≥ria apenas para l√≠deres
      setInterval(() => {
          if (this.node.leaderId === this.node.id && Math.random() < 0.6) {
              this.failNode();
          }
      }, 15000);
  }

  // === Mecanismo de Heartbeat (Detec√ß√£o de Falhas) ===
  startHeartbeat(): void {
    setInterval(async () => {
        if (this.node.isAlive && 
            this.node.leaderId !== null && 
            this.node.leaderId !== this.node.id) {
            
            try {
                await axios.get(`http://localhost:${this.node.leaderId}/heartbeat`);
            } catch (error) {
                console.log(`üíî [N√≥ ${this.node.id}] L√≠der ${this.node.leaderId} n√£o respondeu. Iniciando elei√ß√£o...`);
                await this.startElection(); // Se o l√≠der falhar, inicia nova elei√ß√£o
            }
        }
    }, this.HEARTBEAT_INTERVAL);
  }

  getNode() {
    return this.node;
  }
}

export class Node {
  id: number;
  leaderId: number | null;
  isAlive: boolean;

  constructor(id: number) {
      this.id = id;
      this.leaderId = null;
      this.isAlive = true;
  }
}

import express from "express";
import { createRouter } from "./routes/ElectionRoutes";

const app = express();
app.use(express.json());

const args = process.argv.slice(2);
const nodeId: number = parseInt(args[0]);
const ports: number[] = args.slice(1).map(Number);


app.use(createRouter(nodeId, ports));

app.listen(nodeId, () => {
    console.log(`üöÄ [N√≥ ${nodeId}] Servidor rodando na porta ${nodeId}`);
});



Agora vai o projeto 2:
import dgram from  'dgram';
import {Message, ControlMessage} from '../../types/types';
import { logDebug, logError, logInfo } from '../../utils/logger';

export class MulticastCommunicator {
  private socket: dgram.Socket;
  private address: string;
  private port: number;
  private nodeId: string;
  private messageCallback!: (msg: Message | ControlMessage) => void;

  constructor(
    nodeId: string,
    address: string,
    port: number,
    messageCallback: (msg: Message | ControlMessage) => void
  ) {
    this.nodeId = nodeId;
    this.address = address;
    this.port = port;
    this.messageCallback = messageCallback;

    this.socket = dgram.createSocket({ type: 'udp4', reuseAddr: true });
    this.setupSocketEvents();
  }

  private setupSocketEvents() {
    this.socket.on('error', (err) => {
      logError(`Socket error: ${err.message}`);
      this.socket.close();
    })

    this.socket.on('message', (msg, info) => {
      try{
        const data = JSON.parse(msg.toString()) as Message | ControlMessage;
        if ((data as Message).origin === this.nodeId || (data as ControlMessage).originNode === this.nodeId) {
          // Ignorar mensagens enviadas pelo pr√≥prio n√≥
          return;
        }

        logDebug(`Received message from ${info.address}:${info.port} - ${msg.toString()}`);

        // Enviar para o callback de processamento
        this.messageCallback(data);
      } catch (error) {
        logError(`Error processing message: ${error}`);
      }
    })

    this.socket.on('listening', () => {
      const address = this.socket.address();
      logDebug(`Multicast socket listening on ${address.address}:${address.port}`);

      this.socket.addMembership(this.address);
      logInfo(`Joined multicast group ${this.address}:${this.port}`);
    })
  }

  public start(){
    this.socket.bind(this.port, () => {
      logInfo(`Node ${this.nodeId} starting on group ${this.address}:${this.port}`);
    })
  }

  public sendMessage(msg: Message | ControlMessage) {
    const messageBuffer = Buffer.from(JSON.stringify(msg));
    this.socket.send(messageBuffer, 0, messageBuffer.length, this.port, this.address, (err) => {
      if (err) {
        logError(`Error sending message: ${err.message}`);
      } else {
        logDebug(`Sent message to ${this.address}:${this.port} - ${JSON.stringify(msg)}`);
      }
    })
  }

  public stop(){
    this.socket.dropMembership(this.address);
    this.socket.close(() => {
      logInfo(`Node ${this.nodeId} left multicast group ${this.address}:${this.port}`);
    })
  }
}

import fs from 'fs';
import path from 'path';
import { Message } from '../../types/types';
import { Replicator } from './replication';
import { logDebug, logError, logInfo } from '../../utils/logger';

export class Reconciler {
  private replicator: Replicator
  private intervalExecution: number;
  private intervalId: NodeJS.Timeout | null = null;

  constructor(replicator: Replicator, intervalExecution: number = 10_000) {
    this.replicator = replicator;
    this.intervalExecution = intervalExecution;
  }

  public start() {
    logInfo(`Starting reconciler with interval of ${this.intervalExecution}ms`);

    this.intervalId = setInterval(() => {
      this.reconcile();
    }, this.intervalExecution);
  }

  public stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
      logInfo('Reconciler stopped');
    }
  }


  public reconcile() {
    logInfo('Starting reconciliation process');

    try {
      const allMessages: Map<number, Message[]> = this.replicator.getAllMessages();

      const uniqueMessages: Map<string, Message> = new Map();

      allMessages.forEach((messages) => {
        messages.forEach((message) => {
          if (!uniqueMessages.has(message.id) ||
            uniqueMessages.get(message.id)!.timestamp < message.timestamp
          ) {
            uniqueMessages.set(message.id, message);
          }
        });
      });

      let foundedInconsistencies = false;
      allMessages.forEach((messages, replicaId) => {
        const actualReplicaIds = new Set(messages.map((message) => message.id));

        const missingMessages = Array.from(uniqueMessages.values()).filter(m => !actualReplicaIds.has(m.id));

        if (missingMessages.length > 0) {
          foundedInconsistencies = true;
          logInfo(`Replica ${replicaId} is missing ${missingMessages.length} messages. Syncing...`);

          missingMessages.forEach((message) => {
            this.replicator.saveMessage(message);
          });
        }
      })

      if (!foundedInconsistencies) {
        logInfo('No inconsistencies found');
      } else {
        logInfo('Reconciliation process completed');
      }
    } catch (error) {
      logError(`Error during reconciliation: ${error}`);
    }
  }
}

import fs from 'fs';
import path from 'path';
import { Message } from '../../types/types';
import { logDebug, logError, logInfo } from '../../utils/logger';

export class Replicator {
  private basePath: string;
  private replicasNumber: number;
  private maxDelay: number;

  constructor(basePath: string, replicasNumber: number, maxDelay: number) {
    this.basePath = basePath;
    this.replicasNumber = replicasNumber;
    this.maxDelay = maxDelay;

    this.initializeReplicas();
  }

  private initializeReplicas() {
    if(!fs.existsSync(this.basePath)){
      fs.mkdirSync(this.basePath, { recursive: true });
    }

    for (let i = 1; i <= this.replicasNumber; i++) {
      const replicaPath = path.join(this.basePath, `replica_${i}`);
      if (!fs.existsSync(replicaPath)) {
        fs.mkdirSync(replicaPath, { recursive: true });
      }
    }

    logInfo(`${this.replicasNumber} replicas initialized in ${this.basePath}`);
  }

  public saveMessage(message: Message) {
    for (let i = 1; i <= this.replicasNumber; i++) {
      const delay = Math.floor(Math.random() * this.maxDelay);

      setTimeout(() => {
        const replicaPath = path.join(this.basePath, `replica_${i}`);
        const filePath = path.join(replicaPath, `${message.id}.json`);

        fs.writeFile(filePath, JSON.stringify(message), (err) => {
          if (err) {
            logError(`Error saving message to replica ${i}: ${err}`);
          } else {
            logDebug(`Message ${message.id} saved to replica ${i} after ${delay}ms`);
          }
        });
      }, delay);
    }
  }

  public getReplicaMessage(replicaNumber: number) {
    try {
      const replicaPath = path.join(this.basePath, `replica_${replicaNumber}`);
      const files = fs.readdirSync(replicaPath);

      const messages: Message[] = [];

      for (const file of files) {
        if (file.endsWith('.json')) {
          const content = fs.readFileSync(path.join(replicaPath, file), 'utf-8');
          const message: Message = JSON.parse(content);
          messages.push(message);
        }
      }

      return messages.sort((a, b) => a.timestamp - b.timestamp);
    } catch (error) {
      logError(`Error reading replica ${replicaNumber}: ${error}`);
      return [];
    }
  }

  public getAllMessages(): Map<number, Message[]> {
    const allMessages = new Map<number, Message[]>();

    for (let i = 1; i <= this.replicasNumber; i++) {
      const messages = this.getReplicaMessage(i);
      allMessages.set(i, messages);
    }

    return allMessages;
  }
}

import { ControlMessage, ControlMessageType } from "../../types/types";
import { logDebug, logInfo, logWarning } from "../../utils/logger";

export class MutualExclusion {
  private nodeId: string;
  private isResourceWaiting: boolean = false;
  private isResourceExisting: boolean = false;
  private timestamp: number = 0;
  private queue: {nodeId: string, timestamp: number}[] = [];
  private receivedMessages: Set<string> = new Set();
  private knownNodes: Set<string> = new Set();
  private sendCallback: (message: ControlMessage) => void;
  private receivedResourceCallback: () => void;

  constructor(
    nodeId: string,
    sendCallback: (message: ControlMessage) => void,
    receivedResourceCallback: () => void
  ) {
    this.nodeId = nodeId;
    this.sendCallback = sendCallback;
    this.receivedResourceCallback = receivedResourceCallback;
  }

  public processMessage(message: ControlMessage) {
    this.knownNodes.add(message.originNode);
    
    switch (message.type) {
      case ControlMessageType.REQUEST:
        this.processRequest(message);
        break;
      case ControlMessageType.RESPONSE:
        this.processResponse(message);
        break;
      case ControlMessageType.RELEASE:
        this.processRelease(message);
        break;
    }
  }


  public requestResource() {
    if(this.isResourceWaiting){
      logWarning(`Node ${this.nodeId} is already waiting for a resource`);
      return;
    }

    if(this.isResourceExisting){
      logWarning(`Node ${this.nodeId} is already having a resource`);
      return;
    }

    this.timestamp++;
    
    this.isResourceWaiting = true;
    this.receivedMessages.clear();

    logInfo(`Node ${this.nodeId} is requesting a resource with timestamp ${this.timestamp}`);

    // Se n√£o houver outros n√≥s conhecidos, concede o recurso imediatamente
    if(this.knownNodes.size === 0){
      this.giveResource();
      return;
    }

    const message: ControlMessage = {
      type: ControlMessageType.REQUEST,
      originNode: this.nodeId,
      timestamp: this.timestamp
    }

    this.sendCallback(message);
    this.verifyResponse();
  }

  public releaseResource(){
    if(!this.isResourceExisting){
      logWarning(`Node ${this.nodeId} is not having a resource`);
      return;
    }

    logInfo(`Node ${this.nodeId} is releasing shared resource`);

    this.isResourceExisting = false;
    this.isResourceWaiting = false;

    const message: ControlMessage = {
      type: ControlMessageType.RELEASE,
      originNode: this.nodeId,
      timestamp: this.timestamp
    }

    this.sendCallback(message);

    this.processQueue();
  }

  private processRequest(message: ControlMessage){
    logDebug(`Node ${this.nodeId} received request from ${message.originNode} with timestamp ${message.timestamp}`);

    if(
      this.isResourceExisting ||this.isResourceWaiting && 
      (
        this.timestamp < message.timestamp ||
        (
          this.timestamp === message.timestamp &&
          this.nodeId < message.originNode
        )
      )
    ) {
      this.queue.push({
        nodeId: message.originNode,
        timestamp: message.timestamp
      })
      logDebug(`Node ${this.nodeId} added ${message.originNode} to queue`);
    } else {
      this.sendResponse(message.originNode);
    }
  }


  private sendResponse(destination: string){
    const response: ControlMessage = {
      type: ControlMessageType.RESPONSE,
      originNode: this.nodeId,
      timestamp: this.timestamp
    }

    logDebug(`Node ${this.nodeId} is sending response to ${destination}`);
    this.sendCallback(response);
  }

  private processResponse(message: ControlMessage){
    if (!this.isResourceWaiting) {
      return;
    }

    logDebug(`Node ${this.nodeId} received response from ${message.originNode} with timestamp ${message.timestamp}`);

    this.receivedMessages.add(message.originNode);

    this.verifyResponse();

  }

  private verifyResponse() {
    if(this.receivedMessages.size >= this.knownNodes.size){
      this.giveResource();
    }
  }

  private giveResource(){
    this.isResourceExisting = true;
    this.isResourceWaiting = false;

    logInfo('Resource granted with success');

    this.receivedResourceCallback();
  }

  private processRelease(message: ControlMessage){
    logDebug(`Node ${this.nodeId} received release from ${message.originNode} with timestamp ${message.timestamp}`);

    this.processQueue();
  }


  private processQueue(){
    if(this.queue.length > 0){
      this.queue.sort((a, b) => {
        if(a.timestamp !== b.timestamp){
          return a.timestamp - b.timestamp;
        }
        return a.nodeId.localeCompare(b.nodeId);
      })
    }

    while(this.queue.length > 0){
      const next = this.queue.shift()!;
      this.sendResponse(next.nodeId);
    }
  }

  public addKnownNode(nodeId: string){
    if(nodeId !== this.nodeId) {
      this.knownNodes.add(nodeId);
      logDebug(`Node ${this.nodeId} added known node ${nodeId}`);
    }
  }

  public getStatus(): {isWaiting: boolean, isExisting: boolean} {
    return {
      isWaiting: this.isResourceWaiting,
      isExisting: this.isResourceExisting
    };
  }
}|

import fs from 'fs';
import path from 'path';
import Database from 'better-sqlite3';
import { Message, Checkpoint } from '../../types/types';
import {logError, logInfo } from '../../utils/logger';

export class CheckpointManager {
  private dbPath: string;
  private db: Database.Database;
  private nodId: string;
  private checkpointInterval: number;
  private intervalId: NodeJS.Timeout | null = null;
  private getCallbackMessages: () => Message[];

  constructor(
    nodId: string,
    basePath: string,
    checkpointInterval: number,
    getCallbackMessages: () => Message[]
  ) {
    this.nodId = nodId;

    if (!fs.existsSync(basePath)) {
      fs.mkdirSync(basePath, { recursive: true });
      logInfo(`Created directory: ${basePath}`);
    }

    this.dbPath = path.join(basePath, `${nodId}-checkpoint.db`);
    this.checkpointInterval = checkpointInterval;
    this.getCallbackMessages = getCallbackMessages;

    this.db = new Database(this.dbPath);
    this.initDatabase();
  }

  private initDatabase() {
    this.db.exec(`
      CREATE TABLE IF NOT EXISTS checkpoints (
        id TEXT PRIMARY KEY,
        node_id TEXT NOT NULL,
        timestamp INTEGER NOT NULL,
        data TEXT NOT NULL
      );
    `);

    logInfo(`Checkpoint database initialized at ${this.dbPath}`);
  }

  public init(){
    logInfo(`Starting checkpoint manager with interval of ${this.checkpointInterval}ms`);

    this.intervalId = setInterval(() => {
      this.createCheckpoint();
    }, this.checkpointInterval);
  }

  public stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
      logInfo('Checkpoint manager stopped');
    }
  }

  public createCheckpoint(): string {
    try{
      const messages = this.getCallbackMessages();
      const timestamp = Date.now();
      const checkpointId = `${this.nodId}-${timestamp}`;

      const checkpoint: Checkpoint = {
        id: checkpointId,
        messages,
        timestamp
      };

      const stmt = this.db.prepare(
        'INSERT INTO checkpoints (id, node_id, timestamp, data) VALUES (?, ?, ?, ?)'
      )

      stmt.run(checkpointId, this.nodId, timestamp, JSON.stringify(checkpoint.messages));

      logInfo(`Checkpoint ${checkpointId} created with ${messages.length} messages`);
      return checkpointId
    }catch(e){
      logError(`Error creating checkpoint: ${e}`);
      return '';
    }
  }

  public getLastCheckpoint(): Checkpoint | null {
    try{
      const row = this.db.prepare(
        'SELECT id, node_id, timestamp, data FROM checkpoints WHERE node_id = ? ORDER BY timestamp DESC LIMIT 1'
      ).get(this.nodId) as { id: string; node_id: string; timestamp: number; data: string };

      if(!row){
        logInfo('No checkpoints found');
        return null;
      }

      const checkpoint: Checkpoint = {
        id: row.id,
        messages: JSON.parse(row.data),
        timestamp: row.timestamp
      };

      logInfo(`Last checkpoint found: ${checkpoint.id} with ${checkpoint.messages.length} messages`);
      return checkpoint;
    } catch(e){
      logError(`Error getting last checkpoint: ${e}`);
      return null;
    }
  }

  public recoverState() : Message[] {
    const checkpoint = this.getLastCheckpoint();

    if(!checkpoint){
      logInfo('No checkpoints found');
      return [];
    }

    logInfo(`Recovering state from checkpoint ${checkpoint.id} (${new Date(checkpoint.timestamp).toLocaleString()})`);

    return checkpoint.messages;
  }

  public listCheckpoints(): {id: string, timestamp: number, messagesQtd: number}[] {
    try{
      const rows = this.db.prepare(
        'SELECT id, timestamp, data FROM checkpoints WHERE node_id = ? ORDER BY timestamp DESC'
      ).all(this.nodId) as { id: string; timestamp: number; data: string }[];

      return rows.map((row) => ({
        id: row.id,
        timestamp: row.timestamp,
        messagesQtd: JSON.parse(row.data).length
      }));
    } catch(e){
      logError(`Error listing checkpoints: ${e}`);
      return [];
    }
  }

  public close(){
    this.stop();
    this.db.close();
    logInfo('Checkpoint manager closed');
  }
}

export function simulateFailure() : boolean {
  return Math.random() < 0.1; // 10% chance of failure
}

export interface Message {
  id: string;
  origin: string;
  content: string;
  timestamp: number;
}

export enum ControlMessageType {
  REQUEST = "REQUEST",
  RESPONSE = "RESPONSE",
  RELEASE = "RELEASE"
}

export interface ControlMessage {
  type: ControlMessageType;
  originNode: string;
  timestamp: number;
}

export interface Checkpoint {
  id: string;
  messages: Message[];
  timestamp: number;
}

export interface NodeConfiguration {
  id: string;
  multicastAddress: string;
  multicastPort: number;
  replicasPath: string;
  checkpointInterval: number;
}


import chalk from 'chalk';

enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARNING = 2,
  ERROR = 3
}

let currentLogLevel: LogLevel = LogLevel.INFO;

function setLogLevel(level: LogLevel) {
  currentLogLevel = level;
}

function getTimestamp(): string {
  const now = new Date();
  return now.toISOString().replace('T', ' ').slice(0, 19);
}

function logDebug(message: string) {
  if (currentLogLevel <= LogLevel.DEBUG) {
    console.log(chalk.gray(`[${getTimestamp()}] [DEBUG] ${message}`));
  }
}
function logInfo(message: string) {
  if (currentLogLevel <= LogLevel.INFO) {
    console.log(chalk.blue(`[${getTimestamp()}] [INFO] ${message}`));
  }
}
function logWarning(message: string) {
  if (currentLogLevel <= LogLevel.WARNING) {
    console.log(chalk.yellow(`[${getTimestamp()}] [WARN] ${message}`));
  }
}
function logError(message: string) {
  if (currentLogLevel <= LogLevel.ERROR) {
    console.log(chalk.red(`[${getTimestamp()}] [ERROR] ${message}`));
  }
}


export {LogLevel ,setLogLevel, logDebug, logInfo, logWarning, logError}

/**
 * Distributed Chat System
 * 
 * Main application that integrates all modules:
 * 1. Group Communication with Multicast
 * 2. Data Replication and Eventual Consistency
 * 3. Concurrency Control with Distributed Mutual Exclusion
 * 4. Fault Tolerance with Checkpoints and Rollback
 */
import path from 'path';
import readline from 'readline-sync';
import { v4 as uuidv4 } from 'uuid';
import * as dotenv from 'dotenv';
import { Message, ControlMessage, ControlMessageType, NodeConfiguration } from './types/types';
import { MulticastCommunicator } from './modules/1multicast/multicast';
import { Replicator } from './modules/2replication/replication';
import { Reconciler } from './modules/2replication/reconciler';
import { MutualExclusion } from './modules/3mutualExclusion/mutualExclusion';
import { CheckpointManager, simulateFailure } from './modules/4 faultTolerance/checkpoint';
import { logInfo, logError, logWarning, logDebug, setLogLevel, LogLevel } from './utils/logger';

// Load environment configurations
dotenv.config();

// Set of received messages
const receivedMessages: Message[] = [];

// Node configuration
const config: NodeConfiguration = {
  id: process.env.NODE_ID || `node-${Math.floor(Math.random() * 1000)}`,
  multicastAddress: process.env.MULTICAST_ADDRESS || '224.1.1.1',
  multicastPort: parseInt(process.env.MULTICAST_PORT || '5007'),
  replicasPath: process.env.REPLICAS_PATH || path.join(__dirname, '..', 'data', 'replicas'),
  checkpointInterval: parseInt(process.env.CHECKPOINT_INTERVAL || '30000'),
};

// Enable debug logs if needed
if (process.env.DEBUG === 'true') {
  setLogLevel(LogLevel.DEBUG);
} else {
  setLogLevel(LogLevel.INFO);
}

// Function to process received messages
function processMessage(data: Message | ControlMessage) {
  // Check if it's a control message
  if ('type' in data) {
    mutualExclusion.processMessage(data);
    return;
  }
  
  // Check if we've already received this message
  const messageExists = receivedMessages.some(m => m.id === data.id);
  if (messageExists) {
    return;
  }
  
  // Add to message list
  receivedMessages.push(data);
  
  // Display the message
  console.log(`\n${data.origin}: ${data.content}`);
  
  // Replicate the message
  replicator.saveMessage(data);
  
  // Simulate random failure
  if (simulateFailure()) {
    simulateCrash();
  }
}

// Function to send chat message
function sendChatMessage(content: string) {
  // Check if has permission from mutual exclusion algorithm
  const status = mutualExclusion.getStatus();
  
  if (!status.isExisting) {
    console.log('Requesting permission to send message...');
    mutualExclusion.requestResource();
    return; // Message will be sent when resource is acquired
  }
  
  // Create message
  const message: Message = {
    id: uuidv4(),
    origin: config.id,
    content,
    timestamp: Date.now()
  };
  
  // Send via multicast
  multicast.sendMessage(message);
  
  // Add to message list
  receivedMessages.push(message);
  
  // Replicate the message
  replicator.saveMessage(message);
  
  // Release the resource
  mutualExclusion.releaseResource();
}

// Callback when resource is acquired
function resourceAcquired() {
  console.log('Permission granted. Type your message:');
  const content = readline.question('> ');
  
  if (content.trim()) {
    sendChatMessage(content);
    console.log('Message sent.');
  } else {
    console.log('Empty message, not sent.');
    mutualExclusion.releaseResource();
  }
}

// Simulate crash and recovery
function simulateCrash() {
  logWarning('SIMULATION: Failure detected. Node will restart...');
  
  // Create checkpoint before "failing"
  const checkpointId = checkpointManager.createCheckpoint();
  
  // Stop all services
  multicast.stop();
  reconciler.stop();
  checkpointManager.stop();
  
  // Clear state
  receivedMessages.length = 0;
  
  // Wait some time before "restarting"
  setTimeout(() => {
    logWarning('SIMULATION: Restarting after failure...');
    
    // Recover messages from last checkpoint
    const recoveredMessages = checkpointManager.recoverState();
    
    // Restore state
    receivedMessages.push(...recoveredMessages);
    
    // Restart services
    multicast.start();
    reconciler.start();
    checkpointManager.init();
    
    logInfo(`Recovery completed. ${recoveredMessages.length} messages restored from checkpoint.`);
  }, 2000);
}

// Function to display command menu
function displayMenu() {
  console.log('\n--- DISTRIBUTED CHAT SYSTEM ---');
  console.log(`Node ID: ${config.id}`);
  console.log('Available commands:');
  console.log('/send - Request permission to send message');
  console.log('/status - Display node status');
  console.log('/messages - Display stored messages');
  console.log('/checkpoint - Create a manual checkpoint');
  console.log('/recover - Simulate failure and recovery');
  console.log('/reconcile - Execute manual reconciliation');
  console.log('/exit - Close application');
  console.log('-----------------------------------\n');
}

// Command line interface
function startCLI() {
  displayMenu();
  
  while (true) {
    const command = readline.question('> ');
    
    switch (command.trim().toLowerCase()) {
      case '/send':
        mutualExclusion.requestResource();
        break;
      
      case '/status':
        const status = mutualExclusion.getStatus();
        console.log(`Status of node ${config.id}:`);
        console.log(`- Waiting for resource: ${status.isWaiting}`);
        console.log(`- Has resource: ${status.isExisting}`);
        console.log(`- Stored messages: ${receivedMessages.length}`);
        console.log(`- Last message: ${receivedMessages.length > 0 ? 
          new Date(receivedMessages[receivedMessages.length-1].timestamp).toLocaleString() : 'None'}`);
        break;
      
      case '/messages':
        console.log(`Stored messages (${receivedMessages.length}):`);
        receivedMessages.forEach((msg, i) => {
          console.log(`${i+1}. [${new Date(msg.timestamp).toLocaleString()}] ${msg.origin}: ${msg.content}`);
        });
        break;
      
      case '/checkpoint':
        const id = checkpointManager.createCheckpoint();
        console.log(`Checkpoint created: ${id}`);
        break;
      
      case '/recover':
        simulateCrash();
        break;
      
      case '/reconcile':
        reconciler.reconcile();
        break;
      
      case '/exit':
        console.log('Shutting down application...');
        multicast.stop();
        reconciler.stop();
        checkpointManager.close();
        process.exit(0);
        break;
      
      case '/help':
        displayMenu();
        break;
      
      default:
        if (command.startsWith('/')) {
          console.log('Unknown command. Type /help to see available commands.');
        } else {
          mutualExclusion.requestResource();
        }
        break;
    }
  }
}

// Initialize components
logInfo('Initializing distributed chat system...');

// 1. Group Communication with Multicast
const multicast = new MulticastCommunicator(
  config.id,
  config.multicastAddress,
  config.multicastPort,
  processMessage
);

// 2. Data Replication
const replicator = new Replicator(config.replicasPath, 3, 1000); // Assuming 3 replicas with max delay of 1000ms
const reconciler = new Reconciler(replicator, 10000); // Reconciliation every 10 seconds

// 3. Distributed Mutual Exclusion
const mutualExclusion = new MutualExclusion(
  config.id,
  (msg: ControlMessage) => multicast.sendMessage(msg),
  resourceAcquired
);

// 4. Fault Tolerance with Checkpoints
const checkpointManager = new CheckpointManager(
  config.id,
  path.join(config.replicasPath, config.id),
  config.checkpointInterval,
  () => [...receivedMessages] // Clone array for checkpoint
);

// Start services
multicast.start();
reconciler.start();
checkpointManager.init();

// Check for checkpoints to recover
const recoveredMessages = checkpointManager.recoverState();
if (recoveredMessages.length > 0) {
  receivedMessages.push(...recoveredMessages);
  logInfo(`State recovered with ${recoveredMessages.length} messages from last checkpoint.`);
}

// Start command interface
startCLI();